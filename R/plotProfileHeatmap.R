#' @title Draw a Coverage Profile Heatmap
#'
#' @description Plot a Coverage Profile Heatmap across multiple ranges
#'
#' @details
#' Convenience function for plotting coverage heatmaps across a common set of
#' ranges, shared between one or more samples. These are most commonly the
#' coverage values from merged samples within a treatment group.
#'
#' A profile data frame here refers to a data.frame (or tibble, or DataFrame)
#' with a coverage value in one column that corresponds to a genomic bin of a
#' fixed size, as generated by \link{getProfileData}. Given that multiple
#' ranges are most likely to be drawn, each profile data frame must be the same
#' size in terms of the number of bins, each of which represent a fixed number
#' of nucleotides.
#'
#' If providing a list of profile data frames, the plot will drawn with each
#' list element as a separate panel within the larger heatmap, which assumes
#' each element to represent a sample group. The order these are passed to the
#' function will be the order in which they are drawn
#'
#' By default (addHist = `TRUE`) a summarised histogram will be drawn at the
#' top of each sample by taking the mean coverage within each genomic bin.
#'
#' @param profiles A set of profile data.frames, or a list of these data frames.
#' See details.
#' @param ids The IDs for the profiles. Most commonly the range as a character
#' vector
#' @param valueCol The column in each profile data.frame with the coverage value
#' @param valueLab The label to use for the legend, e.g. CPM, Coverage etc
#' @param xCol The column name to be used for the x-axis
#' @param xLab The label for the x-axis
#' @param addHist logical(1). Add a line histogram to the top of the heatmap
#' @param relHeights The relative heights of the histogram and heatmap. Ignored
#' if addHist = `FALSE`
#' @param scaleTo Scale values to the median, mean etc of the provided profile
#' data frame. Currently, this value will be subtracted from the score for
#' greater comparability across multiple samples within the same heatmap
#' @param ... Not used
#'
#' @return
#' A `ggplot2` object, able to be customised using standard `ggplot2` syntax
#'
#' @examples
#' bw <- system.file("tests", "test.bw", package = "rtracklayer")
#' gr <- GRanges("chr2:500")
#' pd <- getProfileData(bw, gr, upstream = 100, bins = 10)
#' ## This looks terrible given it's a single range with even coverage
#' ## but the syntax should be helpful
#' plotProfileHeatmap(pd$profile_data, ids = granges(pd))
#'
#' @importFrom dplyr arrange desc group_by summarise
#' @importFrom rlang '!!' sym '!!!' syms
#' @importFrom forcats fct_rev fct_inorder
#' @importFrom ggplot2 scale_x_discrete scale_x_continuous scale_y_discrete
#' @importFrom ggplot2 ggplot aes aes_string labs theme facet_wrap
#' @importFrom ggplot2 geom_raster element_blank expansion
#' @importFrom ggside geom_xsideline scale_xsidey_continuous
#' @importFrom tidyselect everything all_of
#'
#' @export
plotProfileHeatmap <- function(
  profiles,
  ids,
  valueCol = "score", valueLab = "Relative\nCoverage",
  xCol = "bp", xLab = "Distance from Centre (bp)",
  addHist = TRUE, relHeights = c(0.3, 0.7),
  scaleTo = c("median", "mean", "max", "min", "none"), ...
) {

  if (missing(ids)) stop("IDs for each range must be provided")
  ids <- as.character(ids)

  scaleTo <- match.arg(scaleTo)
  ## After tidying, we should have a single df with all ranges combined
  ## Range/ID will be in the column 'id' whilst the x-coords will be in xCol
  ## and the fill values for the heatmap fill will be in valueCol.
  ## If mutiiple treats/celllines etc, these will be in the name column
  if (is(profiles, "list")) {
    nm <- names(profiles)
    if (is.null(nm)) {
      message("No names provided on list of profiles. Setting to defaults")
      nm <- paste0("X", seq_along(profiles))
      names(profiles) <- nm
    }
    data <- lapply(
      profiles, .tidySingleProfileSet,
      valueCol = valueCol, ids = ids, scaleTo = scaleTo
    )
    data <- as_tibble(lapply(data, list))
    data <- unnest(
      pivot_longer(data, everything()),
      all_of("value")
    )
    data[["name"]] <- factor(data[["name"]], levels = nm)
  } else {
    data <- .tidySingleProfileSet(
      profiles, valueCol = valueCol, ids = ids, scaleTo = scaleTo
    )
  }
  if (!xCol %in% colnames(data))
    stop("All data frames must contain the column ", xCol)
  data <- arrange(data, desc(!!sym(valueCol)))
  data[["id"]] <- fct_rev(fct_inorder(data[["id"]]))

  ## Autodetect the x-axis as continuous or discrete
  x_axis <- scale_x_discrete(expand = rep(0, 4))
  if (is.numeric(data[[xCol]]))
    x_axis <- scale_x_continuous(expand = rep(0, 4))

  p <- ggplot(data, aes_string(x = xCol, y = "id", fill = valueCol)) +
    geom_raster() +
    x_axis +
    scale_y_discrete(breaks = NULL, label= NULL) +
    labs(x = xLab, y = NULL, fill = valueLab)

  ## Add the top histogram
  if (addHist) {
    grps <- intersect(c(xCol, "name"), colnames(p$data))
    grp_data <- group_by(p$data, !!!syms(grps))
    grp_data <- summarise(
      grp_data, mean = mean(!!sym(valueCol)), .groups = "drop"
    )
    p <- p +
      geom_xsideline(
        aes_string(x = xCol, y = "mean"), data = grp_data, inherit.aes = FALSE
      ) +
      scale_xsidey_continuous(expand = expansion(c(0.1, 0.1))) +
      theme(
        panel.grid.minor = element_blank(),
        ggside.panel.scale = relHeights[[1]] / sum(relHeights)
      )
  }

  ## Facet on each original list element, which will be in the 'name' column
  if ("name" %in% colnames(data)) {
    chkRows <- vapply(split(p$data, f = p$data[["name"]]), nrow, integer(1))
    if (length(unique(chkRows)) != 1)
      stop("All samples must have identical ranges")
    p <- p + facet_wrap(~name)
  }
  p

}
#' @importFrom tidyr pivot_longer unnest
#' @importFrom tidyselect everything all_of
.tidySingleProfileSet <- function(x, valueCol, ids, scaleTo) {

  ## This is designed to work on tibbles, data.frames and DataFrames
  ## Check all data frames have the required cols & same dimensions
  chkCols <- vapply(x, function(x){valueCol %in% colnames(x)}, logical(1))
  if (!all(chkCols)) stop("All DataFrames must contain the column ", valueCol)
  chkRows <- vapply(x, nrow, integer(1))
  if (!all(chkRows == max(chkRows)))
    stop("All data frames must have the same number of rows")

  ## Convert to tibbles then pivot & unnest
  tbl <- lapply(x, as_tibble)
  stopifnot(length(ids) == length(tbl))
  names(tbl) <- ids
  tbl <- as_tibble(lapply(tbl, list))
  tbl <- pivot_longer(tbl, everything(), names_to = "id")
  tbl <- unnest(tbl, all_of("value"))
  ##############################################
  ## Keep testing to figure the best strategy ##
  ##############################################
  ## Define the values to scale to
  f <- function(x, ...){x}
  if (scaleTo != "none") f <- match.fun(scaleTo)
  scale_val <- f(tbl[[valueCol]])
  # tbl[[valueCol]] <- tbl[[valueCol]] / scale_val
  tbl[[valueCol]] <- tbl[[valueCol]] - scale_val # Or divide?

  tbl

}
