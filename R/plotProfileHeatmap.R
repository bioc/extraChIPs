#' @title Draw a coverage Profile Heatmap
#'
#' @description Plot a coverage Profile Heatmap across multiple ranges
#'
#' @details
#' Convenience function for plotting coverage heatmaps across a common set of
#' ranges, shared between one or more samples. These are most commonly the
#' coverage values from merged samples within a treatment group. THe input
#' data structure is based on that obtained from \link{getProfileData}, and can
#' be provided either as a GRanges object (generally for one sample) or as a
#' GRangesList.
#'
#' A 'profile DataFrame' here refers to a data.frame (or tibble, or DataFrame)
#' with a coverage value in one column that corresponds to a genomic bin of a
#' fixed size denoted in another, as generated by \link{getProfileData}.
#' Given that multiple ranges are most likely to be drawn, each profile data
#' frame must be the same size in terms of the number of bins, each of which
#' represent a fixed number of nucleotides. At a minimum this is a two column
#' data frame although getProfileData will provide three columns for each
#' specified genomic region.
#'
#' If using a GRangesList, each list element will be drawn as a separate panel
#' by default. These panels will appear in the same order as the list elements
#' of the GRangesList, although this can easily be overwritten by passing a
#' column name to the facetX argument. The default approach will add the
#' original element names as the column "name" which can be seen in the $data
#' element of any resultant ggplot object produced by this function.
#'
#' @param object A GRanges or GRangesList object
#' @param profileCol Column name specifying where to find the profile DataFrames
#' @param xValue,fillValue Columns within the profile DataFrames for heatmaps
#' @param facetX,facetY Column used for facetting across the x- or y-axis
#' respectively
#' @param colour Column used for colouring lines in the summary panel. Defaults
#' to any column used for facetY
#' @param linetype Column used for linetypes in the summary panel
#' @param summariseBy Function for creating the summary plot in the top panel.
#' If set to 'none', no summary plot will be drawn. Otherwise the top panel will
#' contain a line-plot representing this summary value for each x-axis bin
#' @param xLab,yLab,fillLab Labels for plotting aesthetics. Can be overwritten
#' using labs() on any returned object
#' @param relHeight The relative height of the top summary panel.
#' Represents the fraction of the plotting area taken up by the summary panel.
#' @param ... Passed to \link[ggplot2]{facet_grid} internally. Can be utilised
#' for switching panel strips or passing a labeller function
#'
#' @return
#' A `ggplot2` object, able to be customised using standard `ggplot2` syntax
#'
#' @examples
#' \donttest{
#' library(rtracklayer)
#' fl <- system.file(
#' "extdata", "bigwig", c("ex1.bw", "ex2.bw"), package = "extraChIPs"
#' )
#' bwfl <- BigWigFileList(fl)
#' names(bwfl) <- c("ex1", "ex2")
#'
#' gr <- GRanges(
#'   c(
#'     "chr10:103880281-103880460", "chr10:103892581-103892760",
#'     "chr10:103877281-103877460"
#'    )
#' )
#' pd <- getProfileData(bwfl, gr)
#' plotProfileHeatmap(pd, "profile_data") +
#'   scale_fill_viridis_c(option = "inferno", direction = -1) +
#'   labs(fill = "Coverage")
#' }
#'
#' @name plotProfileHeatmap
#' @rdname plotProfileHeatmap-methods
#' @import methods
#' @export
setGeneric(
  "plotProfileHeatmap",
  function(object, ...) standardGeneric("plotProfileHeatmap")
)
#' @rdname plotProfileHeatmap-methods
#' @import methods
#' @importFrom forcats fct_inorder
#' @export
setMethod(
  "plotProfileHeatmap",
  signature = signature(object = "GenomicRangesList"),
  function(
    object,
    profileCol, xValue = "bp", fillValue = "score",
    facetX = NULL, facetY = NULL, colour = facetY, linetype = NULL,
    summariseBy = c("mean", "median", "min", "max", "none"),
    xLab = xValue, yLab = NULL, fillLab = fillValue, relHeight = 0.3, ...
  ) {

    ## All elements of the list should usually have identical ranges, however,
    ## this is not enforced given that scenarios can exist where this is not
    ## required

    ## Set the List element names as a column, then use these as the default
    ## for facetting along the x-axis
    if (is.null(names(object))) names(object) <- paste0("X.", seq_along(object))
    gr <- unlist(object)
    stopifnot(is(gr, "GRanges"))
    gr$name <- fct_inorder(names(gr))
    names(gr) <- NULL
    if (is.null(facetX)) facetX <- "name"
    plotProfileHeatmap(
      object = gr, profileCol = profileCol, xValue = xValue,
      fillValue = fillValue, facetX = facetX, facetY = facetY, colour = colour,
      linetype = linetype, summariseBy = summariseBy, xLab = xLab, yLab = yLab,
      fillLab = fillLab, relHeight = relHeight, ...
    )
  }
)
#' @import methods
#' @importFrom S4Vectors mcols
#' @importFrom tidyr unnest
#' @importFrom rlang '!!' sym
#' @importFrom dplyr arrange desc bind_cols
#' @importFrom forcats fct_rev fct_inorder
#' @rdname plotProfileHeatmap-methods
#' @export
setMethod(
  "plotProfileHeatmap",
  signature = signature(object = "GenomicRanges"),
  function(
    object,
    profileCol, xValue = "bp", fillValue = "score",
    facetX = NULL, facetY = NULL, colour = facetY, linetype = NULL,
    summariseBy = c("mean", "median", "min", "max", "none"),
    xLab = xValue, yLab = NULL, fillLab = fillValue, relHeight = 0.3, ...
  ) {

    ## Check the profile data.frames for identical dimensions & required cols
    df <- mcols(object)
    stopifnot(profileCol %in% colnames(df))
    stopifnot(.checkProfileDataFrames(df[[profileCol]], xValue, fillValue))

    ## Check the other columns exist
    keepCols <- setdiff(colnames(df), profileCol)
    specCols <- unique(c(facetX, facetY, colour, linetype))
    if (!is.null(specCols)) stopifnot(all(specCols %in% keepCols))

    ## Tidy the data
    profiles <- c() # Avoiding incorrect R CMD check errors
    tbl <- as_tibble(granges(object))
    if (length(keepCols) > 0) tbl <- bind_cols(tbl, as_tibble(df[keepCols]))
    tbl$profiles <- lapply(df[[profileCol]], as_tibble)
    tbl <- unnest(tbl, profiles)
    tbl <- arrange(tbl, desc(!!sym(fillValue)))
    ## Ensure the ranges are shown with the strongest signal at the top
    tbl$range <- fct_rev(fct_inorder(tbl$range))
    if (!is.null(facetY))
      tbl[[facetY]] <- fct_inorder(as.character(tbl[[facetY]]))

    ## Pass to the private function
    summariseBy <- match.arg(summariseBy)
    .makeFinalProfileHeatmap(
      data = tbl, x = xValue, y = "range", fill = fillValue, colour = colour,
      linetype = linetype, facet_x = facetX, facet_y = facetY,
      summary_fun = summariseBy, rel_height = relHeight, x_lab = xLab,
      y_lab = yLab, fill_lab = fillLab, ...
    )
  }
)


#' @title Make a profile heatmap
#' @description Make a profile heatmap with optional summary panel at the top
#' @details The workhorse function for generating the final heatmap
#' Expects a single data.frame in long form with requisite columns
#' @return A ggplot2 object
#' @param data A data.frame or tibble in long form
#' @param x,y The values mapped to the x & y axes
#' @param fill The column used for heatmap colours
#' @param colour,linetype Columns used for the summary plot in the top panel
#' @param facet_x,facet_y Columns used to facet the plot along these axes
#' @param summary_fun Function used to create the summary value at each position
#' @param rel_height The relative height of the top panel
#' @param x_lab,y_lab,fill_lab _labels added to x/y-axes & the fill legend
#' @param ... Passed to facet_grid
#'
#' @importFrom ggplot2 ggplot aes_string facet_grid theme labs expansion
#' @importFrom ggplot2 geom_raster geom_segment scale_y_discrete
#' @importFrom ggplot2 scale_x_discrete scale_x_continuous element_blank
#' @importFrom ggside geom_xsideline ggside scale_xsidey_continuous
#' @importFrom dplyr group_by summarise
#' @importFrom rlang '!!' sym '!!!' syms
#' @importFrom stats as.formula
#' @keywords internal
.makeFinalProfileHeatmap <- function(
  data, x = NULL, y = NULL, fill = NULL, colour = NULL, linetype = NULL,
  facet_x = NULL, facet_y = NULL,
  summary_fun = c("mean", "median", "min", "max", "none"),
  rel_height = 0.3, x_lab = NULL, y_lab = NULL, fill_lab = NULL, ...
) {

  ## data should be a simple data.frame or tibble used to make the final plot
  all_vars <- c(x, y, fill, colour, linetype, facet_x, facet_y)
  stopifnot(is(data, "data.frame"))
  stopifnot(all(all_vars %in% colnames(data)))
  summary_fun <- match.arg(summary_fun)

  ## The basic plot
  x_axis <- scale_x_discrete(expand = rep(0, 4))
  if (is.numeric(data[[x]])) x_axis <-  scale_x_continuous(expand = rep(0, 4))
  p <- ggplot(
    data,
    aes_string(x = x, y = y, fill = fill, colour = colour, linetype = linetype)
  ) +
    geom_raster() + x_axis +
    scale_y_discrete(breaks = NULL, expand = expansion(c(0, 0))) +
    labs(x = x_lab, y = y_lab, fill = fill_lab)

  ## Given that ggside does not currently create a legend for parameters only
  ## used in these side panels, add some dummy lines here in the main panel.
  ## This will ensure a legend appears for colour or linetype
  if (!is.null(colour) | !is.null(linetype))
    p <- p + geom_segment(
      aes_string(
        x = x, y = y, xend = x, yend = y, colour = colour, linetype = linetype
      ), data = data[1,], inherit.aes = FALSE
    )
  ## Only add the top summary if this is called
  if (summary_fun != "none") {
    f <- match.fun(summary_fun)
    grp_vars <- unique(c(x, facet_x, facet_y, colour, linetype))
    grp_df <- group_by(data, !!!syms(grp_vars))
    summ_df <- summarise(grp_df, y = f(!!sym(fill)), .groups = "drop")
    p <- p + geom_xsideline(
      aes_string(x = x, y = "y", colour = colour, linetype = linetype),
      data = summ_df, inherit.aes = FALSE
    ) + ggside(collapse = "x") +
      scale_xsidey_continuous(expand = c(0.1, 0, 0.1, 0), position = "right") +
      theme(
        panel.grid.minor = element_blank(), ggside.panel.scale = rel_height[[1]]
      )
  }
  ## Add the faceting information
  if (!is.null(facet_x) | !is.null(facet_y)) {
    facet_x <- ifelse(is.null(facet_x), ".", facet_x)
    facet_y <- ifelse(is.null(facet_y), ".", facet_y)
    fm <- as.formula(paste(facet_y, facet_x, sep = "~"))
    p <- p + facet_grid(fm, scales = "free_y", space = "free_y", ...)
  }
  p

}

#' @importFrom methods is
#' @importFrom IRanges commonColnames
.checkProfileDataFrames <- function(df, x, fill) {

  msg <- c()

  ## Expects a SplitDataFrameList, or similar
  ## Needs to check all have the same dimensions & the same column names
  if (is(df, "CompressedSplitDataFrameList")) {
    ## CompressedSplitDataFrameList objects already have the colnames &
    ## DataFrame stuff checked. Check these first for speed
    nr <- vapply(df, nrow, integer(1))
    if (length(unique(nr)) != 1)
      msg <- c(msg, "All elements must have the same number of rows\n")
    if (!all(c(x, fill) %in% commonColnames(df)))
      msg <- c(
        msg,
        paste("Column", setdiff(c(x, fill), commonColnames(df)), "is missing")
      )
    if (!is.null(msg)) {
      message(msg)
      return(FALSE)
    }
    return(TRUE)
  }

  if (!is(df, "list_OR_List")) msg <- c(msg, "Object must be a list_OR_List\n")
  isDF <- vapply(df, is, logical(1), class2 = "DataFrame")
  is_df <- vapply(df, is, logical(1), class2 = "data.frame")
  if (!all(isDF | is_df))
    msg <- c(msg, "Each list element must contain DataFrame or data.frame\n")
  if (!is.null(msg)) {
    message(msg)
    return(FALSE)
  }
  ## Now check the actual data frames
  dims <- vapply(df, dim, integer(2))
  if (length(unique(dims[1, ])) > 1)
    msg <- c(msg, "Each data element must have the same number of rows\n")
  if (length(unique(dims[2, ])) > 1)
    msg <- c(msg, "Each data element must have the same number of columns\n")
  all_names <- vapply(df, colnames, character(dims[2, 1]))
  same_cols <- apply(all_names, 1, function(df) length(unique(df)) == 1)
  if (!x %in% all_names[,1]) msg <- c(msg, paste("Column", x, "is missing\n"))
  if (!fill %in% all_names[,1])
    msg <- c(msg, paste("Column", fill, "is missing"))
  if (!all(same_cols))
    msg <- c(msg, "All elements must have the same column names\n")
  if (!is.null(msg)) {
    message(msg)
    return(FALSE)
  }
  TRUE

}
